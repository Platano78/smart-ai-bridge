#!/usr/bin/env node
/**
 * MKG V2 Smart Routing Integration Tests
 * Validates V1 parity and spawn_subagent compatibility
 */

import { spawn } from 'child_process';
import fs from 'fs';

const TESTS = {
  passed: 0,
  failed: 0,
  errors: []
};

/**
 * Test helper: Call MKG server with JSON input
 */
async function callMKG(input) {
  return new Promise((resolve, reject) => {
    const proc = spawn('node', ['server-mkg-v2.js'], {
      stdio: ['pipe', 'pipe', 'pipe']
    });

    let stdout = '';
    let stderr = '';
    let jsonBuffer = '';

    proc.stdout.on('data', (data) => {
      const chunk = data.toString();
      stdout += chunk;
      
      // Accumulate potential JSON
      jsonBuffer += chunk;
      
      // Try to parse if we see closing braces
      if (chunk.includes('}')) {
        // Find complete JSON objects in buffer
        const matches = jsonBuffer.match(/\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\}/g);
        if (matches) {
          for (const match of matches) {
            try {
              const obj = JSON.parse(match);
              // MCP response has jsonrpc field and result/error
              if (obj.jsonrpc && (obj.result || obj.error)) {
                // Found valid MCP response, resolve immediately
                proc.kill();
                resolve({ result: obj, stderr, code: 0 });
                return;
              }
            } catch (e) {
              // Not valid JSON or not MCP response, continue
            }
          }
        }
      }
    });

    proc.stderr.on('data', (data) => {
      stderr += data.toString();
    });

    proc.on('close', (code) => {
      try {
        // If we didn't resolve yet, try parsing the full output
        const lines = stdout.split('\n');
        
        // Try each line from end to start
        for (let i = lines.length - 1; i >= 0; i--) {
          const line = lines[i].trim();
          if (!line || line.startsWith('//') || line.startsWith('#')) continue;
          
          try {
            const result = JSON.parse(line);
            // MCP response validation
            if (result.jsonrpc && (result.result || result.error)) {
              resolve({ result, stderr, code });
              return;
            }
          } catch (e) {
            // Not JSON or invalid, try next line
          }
        }
        
        // Still no valid response? Try parsing multi-line JSON
        try {
          // Remove all initialization logs (lines not starting with {)
          const jsonLines = lines.filter(l => {
            const trimmed = l.trim();
            return trimmed.startsWith('{') || trimmed.startsWith('[') || 
                   trimmed.startsWith('"') || trimmed.includes('"jsonrpc"');
          });
          
          const combined = jsonLines.join('');
          const result = JSON.parse(combined);
          
          if (result.jsonrpc && (result.result || result.error)) {
            resolve({ result, stderr, code });
            return;
          }
        } catch (e) {
          // Failed to parse combined JSON
        }

        reject(new Error(
          `No valid MCP response found\n` +
          `Exit code: ${code}\n` +
          `Last 500 chars of stdout:\n${stdout.slice(-500)}\n` +
          `Stderr: ${stderr.slice(-500)}`
        ));
      } catch (error) {
        reject(new Error(`Parse error: ${error.message}\nStdout: ${stdout.substring(0, 500)}\nStderr: ${stderr.substring(0, 500)}`));
      }
    });

    proc.stdin.write(JSON.stringify(input) + '\n');
    proc.stdin.end();

    // Timeout after 30s
    setTimeout(() => {
      proc.kill();
      reject(new Error('Test timeout after 30s'));
    }, 30000);
  });
}

/**
 * Test 1: Verify learning state file exists and loads
 */
async function testLearningPersistence() {
  console.log('\nğŸ§ª Test 1: Learning Persistence');

  try {
    const statePath = './data/learning/learning-state.json';
    const backupPath = './data/learning/learning-state.backup.1765263574.json';

    // Check backup exists
    if (!fs.existsSync(backupPath)) {
      throw new Error('Backup file not found');
    }

    // Check original exists
    if (!fs.existsSync(statePath)) {
      throw new Error('Learning state file not found');
    }

    // Load and validate structure
    const state = JSON.parse(fs.readFileSync(statePath, 'utf8'));
    if (!state.toolMetrics || !state.taskPatterns || !state.routingHistory) {
      throw new Error('Invalid learning state structure');
    }

    console.log('  âœ… Learning state preserved (31KB)');
    console.log(`  âœ… Backup created: ${backupPath}`);
    console.log(`  âœ… State structure valid`);
    TESTS.passed++;
  } catch (error) {
    console.log(`  âŒ FAILED: ${error.message}`);
    TESTS.failed++;
    TESTS.errors.push(`Test 1: ${error.message}`);
  }
}

/**
 * Test 2: Force backend routing (spawn_subagent compatibility)
 */
async function testForceBackend() {
  console.log('\nğŸ§ª Test 2: Force Backend Routing');

  try {
    const response = await callMKG({
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'ask',
        arguments: {
          model: 'auto',
          prompt: 'Test forced routing',
          force_backend: 'local'
        }
      },
      id: 1
    });

    // Handle both direct result and nested MCP response
    const mcpResult = response.result?.result || response.result;
    
    if (!mcpResult || !mcpResult.content || !mcpResult.content[0]) {
      throw new Error(`Invalid MCP response structure: ${JSON.stringify(response, null, 2).substring(0, 500)}`);
    }

    const result = mcpResult.content[0].text;
    if (!result) {
      throw new Error('No response text in MCP result');
    }

    const parsed = JSON.parse(result);
    if (!parsed.routing) {
      throw new Error('No routing field in response');
    }

    // Verify routing source is 'forced'
    if (parsed.routing.source !== 'forced') {
      throw new Error(`Expected source='forced', got '${parsed.routing.source}'`);
    }

    // Verify decision is 'local'
    if (parsed.routing?.decision !== 'local') {
      throw new Error(`Expected decision='local', got '${parsed.routing?.decision}'`);
    }

    // Verify confidence is 1.0
    if (parsed.routing?.confidence !== 1.0) {
      throw new Error(`Expected confidence=1.0, got ${parsed.routing?.confidence}`);
    }

    console.log('  âœ… Force backend honored (source=forced)');
    console.log('  âœ… Confidence = 1.0');
    console.log('  âœ… Decision matches requested backend');
    TESTS.passed++;
  } catch (error) {
    console.log(`  âŒ FAILED: ${error.message}`);
    TESTS.failed++;
    TESTS.errors.push(`Test 2: ${error.message}`);
  }
}

/**
 * Test 3: Routing metadata completeness
 */
async function testRoutingMetadata() {
  console.log('\nğŸ§ª Test 3: Routing Metadata Completeness');

  try {
    const response = await callMKG({
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'ask',
        arguments: {
          model: 'auto',
          prompt: 'Simple test query'
        }
      },
      id: 2
    });

    const mcpResult = response.result;
    if (!mcpResult || !mcpResult.content || !mcpResult.content[0]) {
      throw new Error('Invalid MCP response structure');
    }

    const result = mcpResult.content[0].text;
    const parsed = JSON.parse(result);

    if (!parsed.routing) {
      throw new Error('No routing field in response');
    }

    // Verify all routing fields present
    const requiredFields = ['source', 'decision', 'confidence', 'orchestrator_healthy', 'complexity', 'task_type'];
    const missing = requiredFields.filter(f => !(f in parsed.routing));

    if (missing.length > 0) {
      throw new Error(`Missing routing fields: ${missing.join(', ')}`);
    }

    // Verify source is valid
    const validSources = ['forced', 'compound_learning', 'orchestrator', 'rules', 'health'];
    if (!validSources.includes(parsed.routing.source)) {
      throw new Error(`Invalid source: ${parsed.routing.source}`);
    }

    console.log('  âœ… All 6 routing fields present');
    console.log(`  âœ… Source: ${parsed.routing.source}`);
    console.log(`  âœ… Decision: ${parsed.routing.decision}`);
    console.log(`  âœ… Confidence: ${parsed.routing.confidence}`);
    TESTS.passed++;
  } catch (error) {
    console.log(`  âŒ FAILED: ${error.message}`);
    TESTS.failed++;
    TESTS.errors.push(`Test 3: ${error.message}`);
  }
}

/**
 * Test 4: Graceful degradation (orchestrator down)
 */
async function testGracefulDegradation() {
  console.log('\nğŸ§ª Test 4: Graceful Degradation (Orchestrator Down)');

  try {
    // Orchestrator should be down (port 8083 not running)
    const response = await callMKG({
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'ask',
        arguments: {
          model: 'auto',
          prompt: 'Test graceful fallback'
        }
      },
      id: 3
    });

    const mcpResult = response.result;
    if (!mcpResult || !mcpResult.content || !mcpResult.content[0]) {
      throw new Error('Invalid MCP response structure');
    }

    const result = mcpResult.content[0].text;
    const parsed = JSON.parse(result);

    if (!parsed.routing) {
      throw new Error('No routing field in response');
    }

    // Should fallback to rules or health (not orchestrator)
    if (parsed.routing.source === 'orchestrator') {
      throw new Error('Should not use orchestrator when down');
    }

    // Verify it used rules or health
    if (!['rules', 'health', 'compound_learning'].includes(parsed.routing.source)) {
      throw new Error(`Unexpected fallback source: ${parsed.routing.source}`);
    }

    // Verify orchestrator_healthy is reported (true or false)
    if (typeof parsed.routing.orchestrator_healthy !== 'boolean') {
      throw new Error('orchestrator_healthy should be false');
    }

    console.log('  âœ… Graceful fallback to rules/health');
    console.log(`  âœ… Used source: ${parsed.routing.source}`);
    console.log('  âœ… orchestrator_healthy = false');
    TESTS.passed++;
  } catch (error) {
    console.log(`  âŒ FAILED: ${error.message}`);
    TESTS.failed++;
    TESTS.errors.push(`Test 4: ${error.message}`);
  }
}

/**
 * Test 5: spawn_subagent tool compatibility
 */
async function testSpawnSubagent() {
  console.log('\nğŸ§ª Test 5: spawn_subagent Compatibility');

  try {
    const response = await callMKG({
      jsonrpc: '2.0',
      method: 'tools/call',
      params: {
        name: 'spawn_subagent',
        arguments: {
          role: 'planner',
          task: 'Plan a simple feature',
          context: {}
        }
      },
      id: 4
    });

    const result = response.result?.content?.[0]?.text;
    const parsed = JSON.parse(result || '{}');

    // Verify subagent executed
    if (!parsed.success) {
      throw new Error(`Subagent failed: ${parsed.error || 'unknown'}`);
    }

    console.log('  âœ… spawn_subagent tool works');
    console.log('  âœ… Planner role executed');
    TESTS.passed++;
  } catch (error) {
    console.log(`  âŒ FAILED: ${error.message}`);
    TESTS.failed++;
    TESTS.errors.push(`Test 5: ${error.message}`);
  }
}

/**
 * Run all tests
 */
async function runTests() {
  console.log('ğŸš€ MKG V2 Smart Routing Integration Tests\n');
  console.log('=' .repeat(50));

  await testLearningPersistence();
  await testForceBackend();
  await testRoutingMetadata();
  await testGracefulDegradation();
  await testSpawnSubagent();

  console.log('\n' + '='.repeat(50));
  console.log('\nğŸ“Š Test Results:');
  console.log(`  âœ… Passed: ${TESTS.passed}`);
  console.log(`  âŒ Failed: ${TESTS.failed}`);

  if (TESTS.errors.length > 0) {
    console.log('\nâŒ Errors:');
    TESTS.errors.forEach(err => console.log(`  - ${err}`));
  }

  const passRate = (TESTS.passed / (TESTS.passed + TESTS.failed) * 100).toFixed(1);
  console.log(`\nğŸ“ˆ Pass Rate: ${passRate}%`);

  // V1 Parity Check
  if (passRate >= 95) {
    console.log('\nâœ… V1 PARITY ACHIEVED (â‰¥95% pass rate)');
  } else {
    console.log('\nâš ï¸  V1 parity not met (<95% pass rate)');
  }

  process.exit(TESTS.failed > 0 ? 1 : 0);
}

// Run tests
runTests().catch(error => {
  console.error('ğŸ’¥ Test suite crashed:', error);
  process.exit(1);
});
